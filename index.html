<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CrickScore - Updated</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 20px auto;
      padding: 10px;
      background: #f0f4f8;
    }
    h1, h2 {
      text-align: center;
    }
    label {
      font-weight: bold;
    }
    input, select, button {
      margin: 5px 0 15px 0;
      padding: 6px;
      font-size: 1rem;
    }
    .flex-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .scoreboard {
      background: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 0 10px #ccc;
      margin-top: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
    }
    th {
      background: #0077cc;
      color: white;
    }
    .message {
      margin-top: 15px;
      font-size: 1.2rem;
      font-weight: bold;
      color: green;
      text-align: center;
    }
    .error {
      color: red;
      text-align: center;
    }
    .hidden {
      display: none;
    }
    button {
      cursor: pointer;
      background: #0077cc;
      color: white;
      border: none;
      border-radius: 5px;
      min-width: 100px;
      transition: background 0.3s ease;
    }
    button:hover:not(:disabled) {
      background: #005fa3;
    }
    button:disabled {
      background: #999;
      cursor: default;
    }
  </style>
</head>
<body>

  <h1>CrickScore - Cricket Scoring App</h1>

  <!-- Match Setup -->
  <div id="setup-section">
    <h2>Match Setup</h2>
    <div class="flex-row" style="justify-content:center;">
      <div>
        <label>Team A Name:</label><br />
        <input type="text" id="teamA" placeholder="Team A" />
      </div>
      <div>
        <label>Team B Name:</label><br />
        <input type="text" id="teamB" placeholder="Team B" />
      </div>
      <div>
        <label>Overs Limit:</label><br />
        <input type="number" id="oversLimit" min="1" max="50" placeholder="20" />
      </div>
    </div>

    <h3>Players & Bowlers Setup</h3>
    <p>Enter batsmen names for Team A (comma separated):</p>
    <textarea id="batsmenInput" rows="2" style="width:100%;" placeholder="Player1, Player2, Player3, ..."></textarea>

    <p>Enter bowlers names for Team A (comma separated):</p>
    <textarea id="bowlersInput" rows="1" style="width:100%;" placeholder="Bowler1, Bowler2, ..."></textarea>

    <button id="startMatchBtn">Start Match (1st Innings)</button>

    <p class="error" id="setupError" style="display:none;"></p>
  </div>

  <!-- Scoring Section -->
  <div id="scoring-section" class="hidden">
    <h2>Scoring - <span id="inningInfo">1st Innings</span></h2>
    <p><strong>Batting:</strong> <span id="battingTeam"></span> | <strong>Bowling:</strong> <span id="bowlingTeam"></span></p>
    <p><strong>Overs:</strong> <span id="oversDisplay"></span> | <strong>Target:</strong> <span id="targetDisplay">N/A</span></p>

    <div class="flex-row" style="justify-content:center; align-items:center;">
      <div>
        <label>Current Batsman:</label><br />
        <select id="currentBatsmanSelect"></select>
      </div>
      <div>
        <label>Current Bowler:</label><br />
        <select id="currentBowlerSelect"></select>
      </div>
    </div>

    <div class="flex-row" style="justify-content:center;">
      <button onclick="addRuns(0)">0</button>
      <button onclick="addRuns(1)">1</button>
      <button onclick="addRuns(2)">2</button>
      <button onclick="addRuns(3)">3</button>
      <button onclick="addRuns(4)">4</button>
      <button onclick="addRuns(5)">5</button>
      <button onclick="addRuns(6)">6</button>
      <button onclick="addWide()">Wide</button>
      <button onclick="addLegBye()">Leg Bye</button>
      <button onclick="wicket()">Wicket</button>
      <button onclick="undoLastBall()">Undo Last Ball</button>
    </div>

    <p class="message" id="matchMessage"></p>

    <!-- Scoreboard -->
    <div class="scoreboard">
      <h3>Scoreboard</h3>
      <p><strong>Score:</strong> <span id="scoreDisplay">0/0</span></p>
      <p><strong>Balls:</strong> <span id="ballsDisplay">0</span> | <strong>Overs:</strong> <span id="oversCountDisplay">0</span></p>

      <h4>Batsmen Stats</h4>
      <table id="batsmenTable">
        <thead>
          <tr>
            <th>Name</th><th>Runs</th><th>Balls</th><th>4s</th><th>6s</th><th>Status</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

      <h4>Bowler Stats</h4>
      <table id="bowlersTable">
        <thead>
          <tr>
            <th>Name</th><th>Overs</th><th>Runs</th><th>Wickets</th><th>Extras</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <button id="nextInningsBtn" class="hidden" onclick="startSecondInnings()">Start 2nd Innings</button>
    <button id="resetBtn" onclick="resetMatch()">Reset Match</button>
  </div>

  <script>
    // State variables
    let oversLimit = 0;
    let balls = 0;
    let score = 0;
    let wickets = 0;
    let innings = 1; // 1 or 2
    let teamA = '';
    let teamB = '';
    let battingTeam = '';
    let bowlingTeam = '';
    let target = null; // target for 2nd innings
    let matchEnded = false;

    // Players data
    let batsmen = []; // array of objects {name, runs, balls, fours, sixes, isOut, isOnStrike}
    let bowlers = []; // array of objects {name, balls, runs, wickets, extras}
    let currentBatsmanIndex = 0; // index of striker in batsmen[]
    let currentNonStrikerIndex = 1; // non striker index
    let currentBowlerIndex = 0;

    // History stack for undo
    let historyStack = [];

    // Custom rule: Leg bye = 0 runs, but if leg bye count reaches 3, batsman is out
    let legByeCount = 0;

    // HTML elements
    const setupSection = document.getElementById('setup-section');
    const scoringSection = document.getElementById('scoring-section');
    const battingTeamSpan = document.getElementById('battingTeam');
    const bowlingTeamSpan = document.getElementById('bowlingTeam');
    const oversDisplay = document.getElementById('oversDisplay');
    const targetDisplay = document.getElementById('targetDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const ballsDisplay = document.getElementById('ballsDisplay');
    const oversCountDisplay = document.getElementById('oversCountDisplay');
    const matchMessage = document.getElementById('matchMessage');
    const currentBatsmanSelect = document.getElementById('currentBatsmanSelect');
    const currentBowlerSelect = document.getElementById('currentBowlerSelect');
    const batsmenTableBody = document.querySelector('#batsmenTable tbody');
    const bowlersTableBody = document.querySelector('#bowlersTable tbody');
    const inningInfo = document.getElementById('inningInfo');
    const nextInningsBtn = document.getElementById('nextInningsBtn');
    const resetBtn = document.getElementById('resetBtn');
    const setupError = document.getElementById('setupError');

    // Start match handler
    document.getElementById('startMatchBtn').addEventListener('click', () => {
      setupError.style.display = 'none';
      // Read inputs
      teamA = document.getElementById('teamA').value.trim() || 'Team A';
      teamB = document.getElementById('teamB').value.trim() || 'Team B';
      oversLimit = parseInt(document.getElementById('oversLimit').value);
      if (!oversLimit || oversLimit < 1) {
        setupError.textContent = 'Please enter a valid overs limit (minimum 1).';
        setupError.style.display = 'block';
        return;
      }
      let batsmenInput = document.getElementById('batsmenInput').value.trim();
      let bowlersInput = document.getElementById('bowlersInput').value.trim();

      if (!batsmenInput) {
        setupError.textContent = 'Please enter at least two batsmen.';
        setupError.style.display = 'block';
        return;
      }
      if (!bowlersInput) {
        setupError.textContent = 'Please enter at least one bowler.';
        setupError.style.display = 'block';
        return;
      }

      let batsmenNames = batsmenInput.split(',').map(s => s.trim()).filter(s => s.length > 0);
      let bowlersNames = bowlersInput.split(',').map(s => s.trim()).filter(s => s.length > 0);

      if (batsmenNames.length < 2) {
        setupError.textContent = 'At least two batsmen are required.';
        setupError.style.display = 'block';
        return;
      }
      if (bowlersNames.length < 1) {
        setupError.textContent = 'At least one bowler is required.';
        setupError.style.display = 'block';
        return;
      }

      // Initialize state for 1st innings: Team A batting, Team B bowling
      innings = 1;
      battingTeam = teamA;
      bowlingTeam = teamB;
      target = null;
      matchEnded = false;
      score = 0;
      wickets = 0;
      balls = 0;
      legByeCount = 0;

      // Initialize batsmen objects
      batsmen = batsmenNames.map((name, i) => ({
        name,
        runs: 0,
        balls: 0,
        fours: 0,
        sixes: 0,
        isOut: false,
        isOnStrike: (i === 0 || i === 1) ? true : false // first 2 on strike (0 striker, 1 non striker)
      }));
      // Make only first 2 batsmen as on strike/non striker
      batsmen.forEach((b, i) => b.isOnStrike = (i === 0 || i === 1));

      currentBatsmanIndex = 0; // striker index
      currentNonStrikerIndex = 1; // non striker index

      // Initialize bowlers
      bowlers = bowlersNames.map(name => ({
        name,
        balls: 0,
        runs: 0,
        wickets: 0,
        extras: 0
      }));
      currentBowlerIndex = 0;

      historyStack = [];

      // Update UI
      setupSection.classList.add('hidden');
      scoringSection.classList.remove('hidden');
      nextInningsBtn.classList.add('hidden');
      resetBtn.disabled = false;

      inningInfo.textContent = '1st Innings';
      battingTeamSpan.textContent = battingTeam;
      bowlingTeamSpan.textContent = bowlingTeam;
      targetDisplay.textContent = 'N/A';

      updateScoreboard();
      updateSelectOptions();

      updateOversDisplay();

      matchMessage.textContent = '';
    });

    // Update batsmen and bowlers select dropdowns
    function updateSelectOptions() {
      // Batsmen select (only not out batsmen)
      currentBatsmanSelect.innerHTML = '';
      batsmen.forEach((b, idx) => {
        if (!b.isOut) {
          let opt = document.createElement('option');
          opt.value = idx;
          opt.textContent = b.name + (b.isOnStrike ? ' (Striker)' : '');
          currentBatsmanSelect.appendChild(opt);
        }
      });

      // Bowler select
      currentBowlerSelect.innerHTML = '';
      bowlers.forEach((b, idx) => {
        let opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = b.name;
        currentBowlerSelect.appendChild(opt);
      });

      currentBatsmanSelect.value = currentBatsmanIndex;
      currentBowlerSelect.value = currentBowlerIndex;

      currentBatsmanSelect.disabled = matchEnded;
      currentBowlerSelect.disabled = matchEnded;
    }

    // Add runs for normal runs (0 to 6)
    function addRuns(runs) {
      if (matchEnded) return;

      const bowler = bowlers[currentBowlerIndex];
      const striker = batsmen[currentBatsmanIndex];
      const nonStriker = batsmen[currentNonStrikerIndex];

      // Save state for undo
      saveHistory({
        runs,
        wide: false,
        legBye: false,
        wicket: false,
        bowlerIndex: currentBowlerIndex,
        strikerIndex: currentBatsmanIndex,
        nonStrikerIndex: currentNonStrikerIndex,
        balls,
        score,
        wickets,
        batsmen: JSON.parse(JSON.stringify(batsmen)),
        bowlers: JSON.parse(JSON.stringify(bowlers)),
        legByeCount
      });

      // Ball counts as legal delivery
      balls++;
      bowler.balls++;

      // Update batsman stats
      striker.runs += runs;
      striker.balls++;
      if (runs === 4) striker.fours++;
      if (runs === 6) striker.sixes++;

      // Update total score
      score += runs;
      bowler.runs += runs;

      // Reset leg bye count on normal run
      legByeCount = 0;

      // Change strike if runs odd
      if (runs % 2 === 1) {
        swapStrike();
      }

      checkOverCompletion();

      updateScoreboard();
      checkMatchEnd();
    }

    // Add wide ball (extra run, no ball counted)
    function addWide() {
      if (matchEnded) return;

      const bowler = bowlers[currentBowlerIndex];

      saveHistory({
        runs: 1,
        wide: true,
        legBye: false,
        wicket: false,
        bowlerIndex: currentBowlerIndex,
        strikerIndex: currentBatsmanIndex,
        nonStrikerIndex: currentNonStrikerIndex,
        balls,
        score,
        wickets,
        batsmen: JSON.parse(JSON.stringify(batsmen)),
        bowlers: JSON.parse(JSON.stringify(bowlers)),
        legByeCount
      });

      // Wide adds 1 run, no ball count
      score++;
      bowler.runs++;
      bowler.extras++;

      legByeCount = 0;

      updateScoreboard();
      checkMatchEnd();
    }

    // Add leg bye (special custom rule: leg bye count = 3 means batsman out)
    function addLegBye() {
      if (matchEnded) return;

      const bowler = bowlers[currentBowlerIndex];
      const striker = batsmen[currentBatsmanIndex];

      saveHistory({
        runs: 0,
        wide: false,
        legBye: true,
        wicket: false,
        bowlerIndex: currentBowlerIndex,
        strikerIndex: currentBatsmanIndex,
        nonStrikerIndex: currentNonStrikerIndex,
        balls,
        score,
        wickets,
        batsmen: JSON.parse(JSON.stringify(batsmen)),
        bowlers: JSON.parse(JSON.stringify(bowlers)),
        legByeCount
      });

      // Ball counts as legal delivery
      balls++;
      bowler.balls++;

      // No runs added (leg = 0 runs)
      // Extras added for leg bye? Usually leg byes are extras, but per your rules leg = 0 runs

      // Count leg bye
      legByeCount++;

      // If leg bye count reaches 3, striker is out
      if (legByeCount >= 3) {
        wicket(true);
        legByeCount = 0; // reset after wicket
      } else {
        // No runs, no strike change (since leg=0), but ball counted
      }

      checkOverCompletion();
      updateScoreboard();
      checkMatchEnd();
    }

    // Wicket falls
    function wicket(fromLegBye = false) {
      if (matchEnded) return;

      const bowler = bowlers[currentBowlerIndex];
      const striker = batsmen[currentBatsmanIndex];

      saveHistory({
        runs: 0,
        wide: false,
        legBye: false,
        wicket: true,
        bowlerIndex: currentBowlerIndex,
        strikerIndex: currentBatsmanIndex,
        nonStrikerIndex: currentNonStrikerIndex,
        balls,
        score,
        wickets,
        batsmen: JSON.parse(JSON.stringify(batsmen)),
        bowlers: JSON.parse(JSON.stringify(bowlers)),
        legByeCount
      });

      // Ball counts as legal delivery
      balls++;
      bowler.balls++;

      // Wicket increment
      wickets++;
      bowler.wickets++;

      // Mark batsman out
      batsmen[currentBatsmanIndex].isOut = true;
      batsmen[currentBatsmanIndex].isOnStrike = false;

      // Reset leg bye count on wicket
      legByeCount = 0;

      // Find next batsman (first not out and not striker or non striker)
      let nextBatsmanIdx = batsmen.findIndex((b, idx) => !b.isOut && idx !== currentNonStrikerIndex && idx !== currentBatsmanIndex);
      if (nextBatsmanIdx === -1) {
        // No more batsmen, innings over
        matchEnded = true;
        matchMessage.textContent = `All out! Innings ${innings} ended.`;
        nextInningsBtn.classList.toggle('hidden', innings === 2);
        disableScoringButtons(true);
        updateScoreboard();
        return;
      }

      // New batsman comes to striker position
      currentBatsmanIndex = nextBatsmanIdx;
      batsmen[currentBatsmanIndex].isOnStrike = true;

      // Keep non striker as is
      batsmen[currentNonStrikerIndex].isOnStrike = true;

      checkOverCompletion();
      updateScoreboard();
      checkMatchEnd();
    }

    // Swap strike batsmen
    function swapStrike() {
      // Swap striker and non-striker indices
      [currentBatsmanIndex, currentNonStrikerIndex] = [currentNonStrikerIndex, currentBatsmanIndex];
      batsmen.forEach((b, idx) => b.isOnStrike = (idx === currentBatsmanIndex || idx === currentNonStrikerIndex));
    }

    // Check if over completed
    function checkOverCompletion() {
      if (balls % 6 === 0) {
        // Over complete
        // Swap strike at over end
        swapStrike();

        // Reset leg bye count on over end
        legByeCount = 0;

        // Move to next bowler automatically if more than 1 bowler
        if (bowlers.length > 1) {
          currentBowlerIndex = (currentBowlerIndex + 1) % bowlers.length;
        }

        updateSelectOptions();
        updateOversDisplay();

        // Check if overs limit reached
        if (Math.floor(balls / 6) >= oversLimit) {
          // Innings end due to overs completed
          matchEnded = true;
          if (innings === 1) {
            matchMessage.textContent = `Overs limit reached. Innings 1 ended.`;
            nextInningsBtn.classList.remove('hidden');
          } else {
            matchMessage.textContent = `Overs limit reached. Match ended.`;
          }
          disableScoringButtons(true);
        }
      } else {
        updateOversDisplay();
      }
    }

    // Update overs display
    function updateOversDisplay() {
      const oversDone = Math.floor(balls / 6);
      const ballsInCurrentOver = balls % 6;
      oversDisplay.textContent = `${oversDone}.${ballsInCurrentOver} / ${oversLimit}`;
      oversCountDisplay.textContent = oversDone + (ballsInCurrentOver / 6);
      ballsDisplay.textContent = balls;
    }

    // Update scoreboard UI
    function updateScoreboard() {
      scoreDisplay.textContent = `${score}/${wickets}`;

      // Batsmen table
      batsmenTableBody.innerHTML = '';
      batsmen.forEach(b => {
        let tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${b.name}${b.isOnStrike ? ' *' : ''}</td>
          <td>${b.runs}</td>
          <td>${b.balls}</td>
          <td>${b.fours}</td>
          <td>${b.sixes}</td>
          <td>${b.isOut ? 'Out' : 'Not Out'}</td>
        `;
        batsmenTableBody.appendChild(tr);
      });

      // Bowlers table
      bowlersTableBody.innerHTML = '';
      bowlers.forEach(b => {
        let oversBowled = Math.floor(b.balls / 6) + '.' + (b.balls % 6);
        let tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${b.name}</td>
          <td>${oversBowled}</td>
          <td>${b.runs}</td>
          <td>${b.wickets}</td>
          <td>${b.extras}</td>
        `;
        bowlersTableBody.appendChild(tr);
      });

      targetDisplay.textContent = target !== null ? target : 'N/A';
      battingTeamSpan.textContent = battingTeam;
      bowlingTeamSpan.textContent = bowlingTeam;
      inningInfo.textContent = innings === 1 ? '1st Innings' : '2nd Innings';
    }

    // Disable or enable scoring buttons
    function disableScoringButtons(disabled) {
      document.querySelectorAll('button').forEach(btn => {
        if (btn.id !== 'resetBtn' && btn.id !== 'nextInningsBtn') {
          btn.disabled = disabled;
        }
      });
      currentBatsmanSelect.disabled = disabled;
      currentBowlerSelect.disabled = disabled;
    }

    // Undo last ball
    function undoLastBall() {
      if (historyStack.length === 0 || matchEnded) return;

      let lastState = historyStack.pop();

      // Restore state
      score = lastState.score;
      wickets = lastState.wickets;
      balls = lastState.balls;
      batsmen = JSON.parse(JSON.stringify(lastState.batsmen));
      bowlers = JSON.parse(JSON.stringify(lastState.bowlers));
      currentBowlerIndex = lastState.bowlerIndex;
      currentBatsmanIndex = lastState.strikerIndex;
      currentNonStrikerIndex = lastState.nonStrikerIndex;
      legByeCount = lastState.legByeCount;
      matchEnded = false;
      matchMessage.textContent = '';
      nextInningsBtn.classList.add('hidden');
      disableScoringButtons(false);
      updateSelectOptions();
      updateScoreboard();
      updateOversDisplay();
    }

    // Save current state to history stack for undo
    function saveHistory(state) {
      historyStack.push(state);
    }

    // Check if match ended due to target or wickets or overs
    function checkMatchEnd() {
      if (innings === 2 && target !== null && score > target) {
        matchEnded = true;
        matchMessage.textContent = `${battingTeam} won the match! Congratulations! 🎉`;
        disableScoringButtons(true);
        nextInningsBtn.classList.add('hidden');
      } else if (wickets >= batsmen.length - 1) {
        matchEnded = true;
        matchMessage.textContent = `All out! Innings ended.`;
        disableScoringButtons(true);
        nextInningsBtn.classList.add('hidden');
      } else if (Math.floor(balls / 6) >= oversLimit) {
        matchEnded = true;
        if (innings === 2) {
          if (score > target) {
            matchMessage.textContent = `${battingTeam} won the match! Congratulations! 🎉`;
          } else if (score === target) {
            matchMessage.textContent = `Match Drawn!`;
          } else {
            matchMessage.textContent = `${battingTeam} lost the match.`;
          }
          disableScoringButtons(true);
          nextInningsBtn.classList.add('hidden');
        } else {
          matchMessage.textContent = `Overs limit reached. Innings ended.`;
          nextInningsBtn.classList.remove('hidden');
          disableScoringButtons(true);
        }
      }
    }

    // Start second innings
    function startSecondInnings() {
      innings = 2;
      battingTeam = teamB;
      bowlingTeam = teamA;
      balls = 0;
      wickets = 0;
      score = 0;
      legByeCount = 0;
      matchEnded = false;
      historyStack = [];

      // Reset batsmen for team B
      const batsmenInput = document.getElementById('batsmenInput').value.trim();
      let batsmenNames = batsmenInput.split(',').map(s => s.trim()).filter(s => s.length > 0);
      batsmen = batsmenNames.map((name, i) => ({
        name,
        runs: 0,
        balls: 0,
        fours: 0,
        sixes: 0,
        isOut: false,
        isOnStrike: (i === 0 || i === 1)
      }));
      currentBatsmanIndex = 0;
      currentNonStrikerIndex = 1;

      // Reset bowlers for team A (we keep same bowlers)
      bowlers.forEach(b => {
        b.balls = 0;
        b.runs = 0;
        b.wickets = 0;
        b.extras = 0;
      });
      currentBowlerIndex = 0;

      target = scoreDisplay.textContent.split('/')[0];
      target = parseInt(target);
      if (!target) target = null;
      if (target !== null) target--; // target is runs to win = first innings score + 1

      targetDisplay.textContent = target !== null ? target : 'N/A';

      inningInfo.textContent = '2nd Innings';
      battingTeamSpan.textContent = battingTeam;
      bowlingTeamSpan.textContent = bowlingTeam;

      nextInningsBtn.classList.add('hidden');
      resetBtn.disabled = false;
      disableScoringButtons(false);

      matchMessage.textContent = '';
      updateScoreboard();
      updateSelectOptions();
      updateOversDisplay();
    }

    // Reset full match
    function resetMatch() {
      location.reload();
    }

    // Update current batsman/bowler on select change
    currentBatsmanSelect.addEventListener('change', (e) => {
      currentBatsmanIndex = parseInt(e.target.value);
      batsmen.forEach((b, idx) => b.isOnStrike = (idx === currentBatsmanIndex || idx === currentNonStrikerIndex));
      updateScoreboard();
    });

    currentBowlerSelect.addEventListener('change', (e) => {
      currentBowlerIndex = parseInt(e.target.value);
      updateScoreboard();
    });
  </script>

</body>
</html>
